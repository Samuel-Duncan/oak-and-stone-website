extends layout

block stylesheets
  
  link(rel='stylesheet', href='/stylesheets/projectDetail.css')

block content
  .project-background
    .dashboard
      if errMsg
        h1= title
        p.error-message= errMsg
      else if projectDetail
        .project-header
          h1.main-title-font= projectDetail.address
          if currentUser && currentUser.isAdmin
            div.project-button-container
              a#viewProject.button.header-button.project-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/update`) 
                span#button-text Edit
                span#spinner-border.spinner-border.spinner-border-sm.d-none(role='status' aria-hidden='true')
              a.button.header-button.project-button.delete-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/delete`)
                svg(xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" stroke="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16" stroke-width="1")
                  path(d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" stroke-linecap="round" stroke-linejoin="round")
          
          if moreThanOneProject
            a#viewProject.button.header-button.project-button(href=`/users/${projectDetail.userId}/projects/`) 
              span#button-text Back
              span#spinner-border.spinner-border.spinner-border-sm.d-none(role='status' aria-hidden='true')


        // DETAILS
        .project-details
          if currentUser.isAdmin
            .detail-item
              h2.dashboard-header Client 
              p.secondary-text= userName
            if lastLogin
              .detail-item
                h2.dashboard-header Last Login 
                p.secondary-text= new Date(lastLogin).toLocaleString('en-US', { weekday: 'long', month: 'long', day: '2-digit', hour: 'numeric', minute: 'numeric', hour12: true, timeZone: 'America/New_York' })
          
          .detail-item
            h2.dashboard-header Phase
            .phase-items
              p.secondary-text #{projectDetail.phaseName}
          
          .detail-item
            h2.dashboard-header Completion Rate
            .phase-items
              p.secondary-text #{projectDetail.currentPhase}%
              div.progress(role='progressbar', aria-label='Progress', aria-valuenow=projectDetail.currentPhase, aria-valuemin='0', aria-valuemax='100')
                div.progress-bar(style=`width: ${projectDetail.currentPhase}%`, aria-valuenow=projectDetail.currentPhase, aria-valuemin='0', aria-valuemax='100')


          if currentUser && currentUser.isAdmin
            .detail-item
              h2.dashboard-header Type
              p.secondary-text= projectDetail.type
        
        // CURRENT UPDATE
        .updates-container
          .detail-item
            .updates-header
              h2.dashboard-header Current Update 
              if currentUser.isAdmin && update === null
                a.button.header-button.project-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/weekly-update/create`)
                  svg(xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16")
                    path(d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4")
              else if currentUser.isAdmin && update !== null || !currentUser.isAdmin && update !== null
                a.button.header-button.project-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/weekly-updates`) View All
            if update !== null
              p.secondary-text.subtitle.project-detail-subtitle Week #{update.week} - #{update.title}
              if update.description
                each line in update.description
                  p.update-description.secondary-text= line
            else
              p.secondary-text No updates to see yet.

        // FILES
        .updates-container 
          .detail-item 
            .updates-header 
              h2.dashboard-header Files 
              if currentUser && currentUser.isAdmin && projectDetail && projectDetail._id
                a.button.header-button.project-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/file/create`)
                  svg(xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16")
                    path(d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4")
            if files && files.length > 0
              // Add a container for files for easier manipulation
              div#file-list-container
                each file in files 
                  if file && file.cloudinaryUrl && file.filename
                    // Add a unique ID to each file item for easy removal
                    div.file-item(id=`file-item-${file._id}` data-file-id=file._id)
                      a.user-list.text-wrap(href=`${file.cloudinaryUrl}` target="_blank")= file.filename
                      |  
                      if currentUser && currentUser.isAdmin && projectDetail && projectDetail._id && file && file._id
                        // Keep the form for progressive enhancement, but we'll handle with JS
                        form.delete-file-form(action=`/users/${projectDetail.userId}/project/${projectDetail._id}/file/${file._id}/delete` method="POST" style="display: inline;")
                          button.button.header-button.project-button.file-button.delete-button.file-delete-btn(type="button" data-file-id=file._id) 
                            svg(xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" stroke="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16" stroke-width="1")
                              path(d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" stroke-linecap="round" stroke-linejoin="round")
                            span.spinner-border.spinner-border-sm.d-none(role='status' aria-hidden='true')
            else
              p.secondary-text#no-files-message No files to see yet.

        // IMAGES
        if images && images.length > 0
          .detail-item
            .updates-header
              h2.dashboard-header Pictures
              if currentUser.isAdmin
                a.button.header-button.project-button.add-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/images`)
                  svg(xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16")
                      path(d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4")
            .image-gallery
              .gallery-grid#image-gallery-grid
                each image in images
                  div.image-container(id=`image-container-${image._id}` data-image-id=image._id)
                    div.image-preview(type="button" data-bs-toggle="modal" data-bs-target="#exampleModal" data-image-url=image.url data-image-id=image._id)
                      img.gallery-image(src=image.url alt="Project Image")
                      p.image-date #{new Date(image.createdAt).toLocaleDateString()}
                    if currentUser && currentUser.isAdmin
                      form.delete-image-button(action=`/users/${projectDetail.userId}/project/${projectDetail._id}/image/${image._id}/delete` method="POST")
                        button.button.header-button.project-button.file-button.delete-button.image-delete(type="submit")
                          svg(xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" stroke="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16" stroke-width="1")
                            path(d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" stroke-linecap="round" stroke-linejoin="round")
            if hasMoreImages
              .load-more-container.text-center.mt-3
                button#loadMoreImagesBtn.button.header-button.project-button Load More
                #imageLoadingSpinner.spinner-border.spinner-border-sm.d-none(role='status' aria-hidden='true')

        else if totalImages === 0
          .detail-item
            .updates-header
                h2 Photos
                if currentUser.isAdmin
                  a.button.header-button.project-button(href=`/users/${projectDetail.userId}/project/${projectDetail._id}/images`)
                    svg(xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16")
                      path(d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4")
            p.secondary-text No images to see yet.

  if images && images.length > 0
    div#exampleModal.modal.fade(tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true")
      div.modal-dialog.modal-dialog-centered.modal-lg
        div.modal-content
          div.modal-header
            button.btn-close.btn-close-white(type="button" data-bs-dismiss="modal" aria-label="Close")
          div.modal-body.p-0
            div#imageCarousel.carousel.slide
              div.carousel-inner
                each image, index in images
                  div.carousel-item(class=index === 0 ? 'active' : '', data-image-id=image._id)
                    img.d-block.w-100(src=image.url alt="Project Image")
                    //- if image.createdAt
                    //-   div.carousel-caption
                    //-     p.image-date.mb-0 #{image.createdAt.toLocaleDateString()}
              button.carousel-control-prev(type="button" data-bs-target="#imageCarousel" data-bs-slide="prev")
                span.carousel-control-prev-icon.carousel-btn.bg-dark(aria-hidden="true")
                span.visually-hidden Previous
              button.carousel-control-next(type="button" data-bs-target="#imageCarousel" data-bs-slide="next")
                span.carousel-control-next-icon.carousel-btn.bg-dark(aria-hidden="true")
                span.visually-hidden Next
            // Comments Section
            div.image-comments-container
              div#comments-loading-spinner.text-center.d-none(role='status')
                span.spinner-border.spinner-border-sm
              div.comments-list
                // Comments will be loaded here by JavaScript
              form.comment-form(data-image-id="")
                // New wrapper for textarea and button
                div.comment-input-wrapper 
                  textarea.form-control.comment-input(name="text" placeholder="Add a comment..." rows="2" required)
                  button.button.header-button.project-button.comment-submit-btn(type="submit") Post

  script.
    const projectUserId = !{JSON.stringify(projectDetail.userId)};
    const projectId = !{JSON.stringify(projectDetail._id)};
    const currentUserId = !{currentUser && currentUser._id ? JSON.stringify(currentUser._id) : null};
    const currentUserIsAdmin = !{currentUser && currentUser.isAdmin ? JSON.stringify(currentUser.isAdmin) : false};
    let currentPage = !{currentPage ? JSON.stringify(currentPage) : 1};
    let isLoadingImages = false;

    document.addEventListener('DOMContentLoaded', function() {
      // Define myModalEl and imageCarousel at the very top of this block
      const myModalEl = document.getElementById('exampleModal');
      const imageCarousel = document.getElementById('imageCarousel'); 
      
      // Initialize Bootstrap Modal instance once
      const modalInstance = myModalEl ? new bootstrap.Modal(myModalEl) : null;

      let activeCommentLoadCall = null; // For tracking the latest loadComments call

      // console.log('[DOMContentLoaded] Initialized myModalEl:', myModalEl);
      // console.log('[DOMContentLoaded] Initialized imageCarousel:', imageCarousel);
      // console.log('[DOMContentLoaded] Initialized modalInstance:', modalInstance);

      // --- Moved from separate block ---
      const imagePreviews = document.querySelectorAll('.image-preview');
      // imageCarousel is now defined before use here
      const carouselInstance = imageCarousel ? new bootstrap.Carousel(imageCarousel, { interval: false }) : null;

      // No global flags needed for this simplified approach
      let g_clickedImageIndex = -1; // Only to help shown.bs.modal know if index 0 was the target
      
      imagePreviews.forEach((preview) => { // Removed 'index' from parameters
        preview.addEventListener('click', function(event) { // 'this' will be the clicked preview element
          event.preventDefault();
          
          const clickedImageId = this.dataset.imageId; // Get imageId from the clicked preview
          const allCarouselItems = modalImageCarouselInner.querySelectorAll('.carousel-item');
          let targetCarouselIndex = -1;

          allCarouselItems.forEach((item, idx) => {
            if (item.dataset.imageId === clickedImageId) {
              targetCarouselIndex = idx;
            }
          });

          g_clickedImageIndex = targetCarouselIndex; // Store the target index for shown.bs.modal
          
          // console.log('[imagePreview click] Clicked Image ID:', clickedImageId, 'Found Carousel Index:', targetCarouselIndex);
          
          if (carouselInstance && targetCarouselIndex !== -1) {
            carouselInstance.to(targetCarouselIndex); // Command carousel to go to the clicked image's index
          } else if (carouselInstance && targetCarouselIndex === -1) {
            console.error('[imagePreview click] Clicked imageId not found in carousel items:', clickedImageId);
            // Potentially handle this error, e.g., by trying to find the first available image or showing an error
            // For now, it will simply not change the slide if not found.
          }


          if (modalInstance) {
            modalInstance.show(); // Then show the modal
          } else {
            // console.error('[imagePreview click] modalInstance is not defined, cannot show modal.');
          }
        });
      });

      // Reset relevant states when modal is closed
      myModalEl.addEventListener('hidden.bs.modal', function () {
        // console.log('[hidden.bs.modal] Event Fired. Resetting state.');
        g_clickedImageIndex = -1;

        const commentsListElement = myModalEl.querySelector('.comments-list');
        if (commentsListElement) {
          commentsListElement.innerHTML = ''; // Clear comments
        }

        const commentForm = myModalEl.querySelector('.comment-form');
        if (commentForm) {
          commentForm.dataset.imageId = ''; // Clear form's image ID
          commentForm.querySelector('textarea[name="text"]').value = ''; // Clear textarea
        }

        if (carouselInstance) {
          // carouselInstance.to(0); // Optionally reset carousel to first slide
          // For now, let's not reset to 0, as the next click will dictate the slide.
          // The critical part is resetting our tracking variables and clearing content.
        }
        // Clear the URL hash
        history.replaceState(null, '', window.location.pathname + window.location.search);

        // Clear any lingering opacity classes from previous hide/show attempts if they exist
        const modalBody = myModalEl.querySelector('.modal-body');
        if (modalBody && modalBody.classList.contains('modal-content-loading')) {
            modalBody.classList.remove('modal-content-loading');
            // Removed height transition reset
            // Removed opacity reset
        }

      });
      // --- End Moved Code ---

      // Functions moved here for correct scope
      function formatTimestamp(isoString) {
        const date = new Date(isoString);
        return date.toLocaleString('en-US', {
          month: 'long',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric',
          hour12: true,
        });
      }

      function displayComment(comment, commentsListElement) {
        const commentItem = document.createElement('div');
        commentItem.classList.add('comment-item');
        commentItem.dataset.commentId = comment._id; // Add commentId for easy access

        const fullUserName = comment.userId && comment.userId.name ? comment.userId.name : 'User';
        const userName = fullUserName.split(' ')[0]; // Get only the first word
        const commentUser = document.createElement('p');
        commentUser.classList.add('comment-user');
        commentUser.textContent = userName;
        const commentText = document.createElement('p');
        commentText.classList.add('comment-text');
        commentText.textContent = comment.text;
        const commentTimestamp = document.createElement('p');
        commentTimestamp.classList.add('comment-timestamp', 'secondary-text');
        commentTimestamp.textContent = formatTimestamp(comment.createdAt);
        commentItem.appendChild(commentUser);
        commentItem.appendChild(commentText);
        commentItem.appendChild(commentTimestamp);

        // Add delete button if the comment belongs to the current user
        // Ensure comment.userId has _id, not just populated name. Adjust if backend sends full user object.
        // Assuming comment.userId is an object with _id or just the ID string.
        const commentOwnerId = comment.userId && typeof comment.userId === 'object' ? comment.userId._id : comment.userId;

        if (currentUserIsAdmin || (currentUserId && commentOwnerId && currentUserId === commentOwnerId.toString())) {
          const deleteButton = document.createElement('button');
          deleteButton.classList.add('button', 'header-button', 'project-button', 'file-button', 'delete-button', 'comment-delete-btn');
          deleteButton.setAttribute('type', 'button'); // Important: not a submit button
          deleteButton.dataset.commentId = comment._id;
          // We'll need imageId if it's not easily accessible from the form or modal data when deleting
          // Assuming imageId will be retrieved from the commentForm's dataset.imageId or similar context

          const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttribute('width', '16');
          svg.setAttribute('height', '16');
          svg.setAttribute('fill', 'none');
          svg.setAttribute('stroke', 'currentColor');
          svg.setAttribute('class', 'bi bi-x-lg');
          svg.setAttribute('viewBox', '0 0 16 16');
          svg.setAttribute('stroke-width', '1');
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('stroke-linejoin', 'round');
          svg.appendChild(path);
          deleteButton.appendChild(svg);

          commentItem.appendChild(deleteButton);
        }

        commentsListElement.appendChild(commentItem);
      }

      async function loadComments(imageId, commentsListElement) {
        // ALWAYS clear existing comments and messages at the very start
        if (commentsListElement) {
          commentsListElement.innerHTML = '';
        }

        const thisCallSymbol = Symbol();
        activeCommentLoadCall = thisCallSymbol;

        // console.log('[loadComments] Called with imageId:', imageId);

        const commentsSpinner = myModalEl.querySelector('#comments-loading-spinner');
        if (commentsSpinner) {
          commentsSpinner.classList.remove('d-none'); // Show spinner
        }

        if (!imageId) {
          // console.warn('[loadComments] No imageId provided.');
          if (commentsSpinner) {
            commentsSpinner.classList.add('d-none'); // Hide spinner if no imageId
          }
          commentsListElement.innerHTML = ''; // Ensure list is clear even if no imageId
          commentsListElement.innerHTML = '<p class="text-center secondary-text">No comments yet. Be the first to comment!</p>';
          // Removed height update call
          return;
        }

        // Always clear existing comments at the start
        commentsListElement.innerHTML = '';

        try {
          // console.log(`[loadComments] Fetching comments for imageId: ${imageId}`);
          const response = await fetch(`/users/${projectUserId}/project/${projectId}/image/${imageId}/comments`);
          // console.log('[loadComments] Fetch response status:', response.status);
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: 'Failed to parse error JSON' }));
            // console.error('[loadComments] Error fetching comments:', errorData);
            throw new Error(errorData.message || 'Failed to load comments');
          }
          const comments = await response.json();
          // console.log('[loadComments] Received comments:', comments);

          if (activeCommentLoadCall !== thisCallSymbol) return; // Stale call, do not update DOM

          if (comments.length === 0) {
            // console.log('[loadComments] No comments found, displaying message.');
            commentsListElement.innerHTML = '<p class="text-center secondary-text">No comments yet. Be the first to comment!</p>';
          } else {
            // console.log(`[loadComments] Displaying ${comments.length} comments.`);
            comments.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            comments.forEach(comment => displayComment(comment, commentsListElement));
          }
          // Removed height update call
        } catch (error) {
          if (activeCommentLoadCall !== thisCallSymbol) return; // Stale call, do not update DOM
          // console.error('[loadComments] Catch block error:', error);
          commentsListElement.innerHTML = '<p class="text-center text-danger">Error loading comments.</p>';
          // Removed height update call
        } finally {
          if (activeCommentLoadCall !== thisCallSymbol) return; // Stale call, do not update DOM
          if (commentsSpinner) {
            commentsSpinner.classList.add('d-none'); // Hide spinner
          }
        }
      }

      async function handleCommentSubmit(event) {
        event.preventDefault();
        const form = event.target;
        const imageId = form.dataset.imageId;
        const commentText = form.querySelector('textarea[name="text"]').value.trim();
        const submitButton = form.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.textContent;

        if (!commentText || !imageId) return;

        // Disable button and show spinner
        submitButton.disabled = true;
        submitButton.innerHTML = ''; // Clear current content
        const spinner = document.createElement('span');
        spinner.classList.add('spinner-border', 'spinner-border-sm');
        spinner.setAttribute('role', 'status');
        spinner.setAttribute('aria-hidden', 'true');
        submitButton.appendChild(spinner);

        try {
          const response = await fetch(`/users/${projectUserId}/project/${projectId}/image/${imageId}/comment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: commentText }),
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Failed to post comment');
          }
          const newComment = await response.json();
          const commentsListElement = form.previousElementSibling;
          const noCommentsMessage = commentsListElement.querySelector('.secondary-text');
          if (noCommentsMessage && noCommentsMessage.textContent.includes('No comments yet')) {
              commentsListElement.innerHTML = '';
          }
          displayComment(newComment, commentsListElement);
          form.querySelector('textarea[name="text"]').value = '';
          // Removed height update call
        } catch (error) {
          // console.error('Error posting comment:', error);
          // Optionally, display an error message to the user
        } finally {
          // Restore button state
          submitButton.innerHTML = originalButtonText;
          submitButton.disabled = false;
        }
      }

      // All other modal logic including myModalEl, imageCarousel, etc. definitions and event listeners
      // Removed height calculation and update functions

      const commentForm = myModalEl.querySelector('.comment-form');
      const commentsListElement = myModalEl.querySelector('.comments-list');

      // console.log('[DOMContentLoaded] myModalEl is:', myModalEl); // Log myModalEl after definition

      if (commentForm) {
        commentForm.addEventListener('submit', handleCommentSubmit);
      }

      if (!myModalEl || !imageCarousel) {
        // console.error('Modal or Image Carousel element not found.');
        return;
      }

      const modalBody = myModalEl.querySelector('.modal-body');

      if (!modalBody) {
        // console.error('Modal body not found.');
        return;
      }

      // Removed height related variables
      // Removed calculateImageDisplayHeight function
      // Removed updateModalBodyHeightForContent function
      // Removed setModalBodyHeight function

      // console.log('[DOMContentLoaded] Attaching Bootstrap modal event listeners to:', myModalEl);
      myModalEl.addEventListener('show.bs.modal', function (event) {
        // console.log('[show.bs.modal] Event Fired! Target:', event.target, 'RelatedTarget:', event.relatedTarget);
      });

      myModalEl.addEventListener('shown.bs.modal', function () {
        // This listener ensures comments are loaded whenever the modal is shown.
        // It finds the currently active carousel item and loads comments for its image ID.
        // console.log('[shown.bs.modal] Event Fired. Loading comments for active image.');

        const currentActiveItem = imageCarousel.querySelector('.carousel-item.active');
        const imageId = currentActiveItem?.dataset.imageId;
        const commentsListElement = myModalEl.querySelector('.comments-list');
        const commentForm = myModalEl.querySelector('.comment-form');

        if (imageId && commentsListElement) {
          loadComments(imageId, commentsListElement);
          history.replaceState(null, '', `#image-${imageId}`);
        }
        if (commentForm && imageId) {
          commentForm.dataset.imageId = imageId;
        }
        if (imageId) {
          history.replaceState(null, '', `#image-${imageId}`);
        }

        // Removed height update call

      });

      // Event listener for when a new slide is about to be shown
      imageCarousel.addEventListener('slide.bs.carousel', function () {
        if (modalBody) {
          // Removed modal body overflow and transition modification
        }
      });

      imageCarousel.addEventListener('slid.bs.carousel', function (event) {
        // console.log('[slid.bs.carousel] Event Fired. New active slide index:', event.to);
        if (modalBody) {
          // Removed transition restoration
        }

        const activeCarouselItem = event.relatedTarget; // The carousel item that just became active
        const activeImageId = activeCarouselItem ? activeCarouselItem.dataset.imageId : null;
        const commentsListElement = myModalEl.querySelector('.comments-list');
        const commentForm = myModalEl.querySelector('.comment-form');

        if (activeImageId && commentsListElement) {
          loadComments(activeImageId, commentsListElement);
          history.replaceState(null, '', `#image-${activeImageId}`);
        }
        if (commentForm && activeImageId) {
          commentForm.dataset.imageId = activeImageId;
        }

        const imgElement = activeCarouselItem ? activeCarouselItem.querySelector('img') : null;

        const finalizeHeightUpdateAndRestoreOverflow = () => {
          // Removed height update call
          if (modalBody) {
            // Removed overflow restoration
          }
        };

        if (imgElement) {
          if (imgElement.complete && imgElement.naturalHeight > 0) {
            finalizeHeightUpdateAndRestoreOverflow();
          } else {
            let loadedOrTimedOut = false;
            const loadOrErrorHandler = () => {
              if (!loadedOrTimedOut) {
                loadedOrTimedOut = true;
                imgElement.removeEventListener('load', loadOrErrorHandler);
                imgElement.removeEventListener('error', loadOrErrorHandler);
                finalizeHeightUpdateAndRestoreOverflow();
              }
            };
            imgElement.addEventListener('load', loadOrErrorHandler);
            imgElement.addEventListener('error', loadOrErrorHandler);

            // Fallback timeout in case load/error events don't fire reliably
            setTimeout(() => {
              if (!loadedOrTimedOut) {
                // console.warn('[slid.bs.carousel] Image load/error event fallback timeout.');
                loadOrErrorHandler();
              }
            }, 300); // Reasonably short timeout

            // Handle cases where image might be 'complete' but didn't fire load (e.g. already cached and errored)
            if (imgElement.complete && !loadedOrTimedOut) {
                 loadOrErrorHandler();
            }
          }
        } else {
          finalizeHeightUpdateAndRestoreOverflow(); // No image element, update based on other content (e.g. comments only)
        }
      });

      window.addEventListener('resize', function () {
        if (myModalEl.classList.contains('show')) {
           // Removed height update call
        }
      });

       // Initial setup on modal open (attaching handlers, etc.) remains mostly the same
       // The logic for loading comments and initial height is now in 'shown.bs.modal'

      // Event listener for deleting comments (using event delegation)
      const commentsContainer = myModalEl.querySelector('.image-comments-container');
      if (commentsContainer) {
        commentsContainer.addEventListener('click', async function(event) {
          const deleteButton = event.target.closest('.comment-delete-btn');
          if (!deleteButton) return; // Click was not on a delete button

          const commentItem = deleteButton.closest('.comment-item');
          const commentId = deleteButton.dataset.commentId;
          // The imageId is needed for the endpoint and should be on the comment form
          const commentFormForImageId = myModalEl.querySelector('.comment-form');
          const imageId = commentFormForImageId ? commentFormForImageId.dataset.imageId : null;

          if (!commentId || !imageId) {
            // console.error('Missing commentId or imageId for delete operation.');
            return;
          }

          // Add spinner to button
          const originalButtonContent = deleteButton.innerHTML;
          deleteButton.disabled = true;
          deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

          try {
            const response = await fetch(`/users/${projectUserId}/project/${projectId}/image/${imageId}/comment/${commentId}`, {
              method: 'DELETE',
              headers: {
                // Add any necessary headers, like CSRF token if your app uses them
                'Content-Type': 'application/json'
              }
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: 'Failed to parse error from server'}));
              throw new Error(errorData.message || 'Failed to delete comment from server');
            }

            // Successfully deleted from server
            if (commentItem) {
              commentItem.remove();
            }

            // Check if any comments are left
            const remainingCommentItems = commentsContainer.querySelectorAll('.comment-item');
            const commentsList = commentsContainer.querySelector('.comments-list');
            if (commentsList && remainingCommentItems.length === 0) {
              commentsList.innerHTML = '<p class="text-center secondary-text">No comments yet. Be the first to comment!</p>';
            }

            // Removed height update call

          } catch (error) {
            // console.error('Error deleting comment:', error);
          } finally {
            // Restore button
            deleteButton.disabled = false;
            deleteButton.innerHTML = originalButtonContent;
          }
        });
      }

      function handlePageLoadImageHash() {
        const hash = window.location.hash;
        if (hash && hash.startsWith('#image-')) {
          const imageIdFromHash = hash.substring('#image-'.length);
          if (imageIdFromHash && carouselInstance && modalInstance) {
            const items = imageCarousel.querySelectorAll('.carousel-item');
            let imageIndex = -1;
            items.forEach((item, index) => {
              if (item.dataset.imageId === imageIdFromHash) {
                imageIndex = index;
              }
            });

            if (imageIndex !== -1) {
              // Store this index so shown.bs.modal knows it was from a direct link
              // This is important if the target is index 0, as slid.bs.carousel might not fire.
              g_clickedImageIndex = imageIndex;
              carouselInstance.to(imageIndex); // Go to the slide
              modalInstance.show(); // Show the modal
            } else {
              // console.warn('Image ID from hash not found in carousel items:', imageIdFromHash);
            }
          } else {
            // console.log('No image ID in hash, or carousel/modal not ready.');
          }
        }
      }

      // Call the new function on DOMContentLoaded
      handlePageLoadImageHash();

      // --- Lazy Loading Logic for Images ---
      const loadMoreImagesBtn = document.getElementById('loadMoreImagesBtn');
      const imageLoadingSpinner = document.getElementById('imageLoadingSpinner');
      const imageGalleryGrid = document.getElementById('image-gallery-grid');
      const modalImageCarouselInner = document.querySelector('#imageCarousel .carousel-inner');

      function createImageGalleryItem(image) {
        const imageContainer = document.createElement('div');
        imageContainer.classList.add('image-container');
        imageContainer.id = `image-container-${image._id}`;
        imageContainer.dataset.imageId = image._id;

        const imagePreviewDiv = document.createElement('div');
        imagePreviewDiv.classList.add('image-preview');
        imagePreviewDiv.type = 'button';
        imagePreviewDiv.dataset.bsToggle = 'modal';
        imagePreviewDiv.dataset.bsTarget = '#exampleModal';
        imagePreviewDiv.dataset.imageUrl = image.url;
        imagePreviewDiv.dataset.imageId = image._id;

        const imgElement = document.createElement('img');
        imgElement.classList.add('gallery-image');
        imgElement.src = image.url;
        imgElement.alt = 'Project Image';

        const imageDate = document.createElement('p');
        imageDate.classList.add('image-date');
        imageDate.textContent = new Date(image.createdAt).toLocaleDateString();

        imagePreviewDiv.appendChild(imgElement);
        imagePreviewDiv.appendChild(imageDate);
        imageContainer.appendChild(imagePreviewDiv);

        if (currentUserIsAdmin) {
          const deleteForm = document.createElement('form');
          deleteForm.classList.add('delete-image-button');
          deleteForm.action = `/users/${projectUserId}/project/${projectId}/image/${image._id}/delete`;
          deleteForm.method = 'POST';

          const deleteButton = document.createElement('button');
          deleteButton.classList.add('button', 'header-button', 'project-button', 'file-button', 'delete-button', 'image-delete');
          deleteButton.type = 'submit';
          deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" stroke="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16" stroke-width="1"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
          deleteForm.appendChild(deleteButton);
          imageContainer.appendChild(deleteForm);
        }

        // Add click listener for the new image preview
        imagePreviewDiv.addEventListener('click', function(event) {
          event.preventDefault();
          // Find index of this image in the updated carousel items
          const allCarouselItems = modalImageCarouselInner.querySelectorAll('.carousel-item');
          let clickedImageCarouselIndex = -1;
          allCarouselItems.forEach((item, idx) => {
            if (item.dataset.imageId === image._id) {
              clickedImageCarouselIndex = idx;
            }
          });

          g_clickedImageIndex = clickedImageCarouselIndex;

          if (carouselInstance && clickedImageCarouselIndex !== -1) {
            carouselInstance.to(clickedImageCarouselIndex);
          }
          if (modalInstance) {
            modalInstance.show();
          }
        });

        return imageContainer;
      }

      function createCarouselItem(image, index, totalInitialImages) {
          const carouselItem = document.createElement('div');
          carouselItem.classList.add('carousel-item');
          // The first image *of this new batch* might need to be active if the carousel was empty.
          // However, standard behavior is to append, and 'active' is usually handled for the very first item overall.
          // Let's assume if modalImageCarouselInner is empty, the first *appended* item becomes active.
          if (modalImageCarouselInner.children.length === 0 && index === 0) {
              carouselItem.classList.add('active');
          }
          carouselItem.dataset.imageId = image._id;

          const img = document.createElement('img');
          img.classList.add('d-block', 'w-100');
          img.src = image.url;
          img.alt = 'Project Image';
          carouselItem.appendChild(img);
          return carouselItem;
      }

      if (loadMoreImagesBtn) {
        loadMoreImagesBtn.addEventListener('click', async function() {
          if (isLoadingImages) return;

          isLoadingImages = true;
          currentPage++;
          loadMoreImagesBtn.classList.add('d-none');
          imageLoadingSpinner.classList.remove('d-none');

          try {
            const response = await fetch(`/users/${projectUserId}/project/${projectId}/api/images?page=${currentPage}`);
            if (!response.ok) {
              throw new Error('Failed to load more images');
            }
            const data = await response.json();

            if (data.images && data.images.length > 0) {
              data.images.forEach((image, index) => {
                // Append to gallery grid
                const galleryItem = createImageGalleryItem(image);
                if (imageGalleryGrid) {
                  imageGalleryGrid.appendChild(galleryItem);
                }
                // Append to modal carousel
                const carouselItem = createCarouselItem(image, index, modalImageCarouselInner.children.length);
                if (modalImageCarouselInner) {
                  modalImageCarouselInner.appendChild(carouselItem);
                }
              });
              // Re-initialize or update carousel if necessary, Bootstrap 5 might handle new items automatically.
              // If not, you might need: if (carouselInstance) carouselInstance.dispose(); carouselInstance = new bootstrap.Carousel(imageCarousel, { interval: false });
            }

            if (!data.hasMoreImages) {
              // No more images to load, hide button permanently (or its container)
              if (loadMoreImagesBtn.parentElement) {
                loadMoreImagesBtn.parentElement.classList.add('d-none');
              }
            } else {
              loadMoreImagesBtn.classList.remove('d-none');
            }
          } catch (error) {
            console.error('Error loading more images:', error);
            loadMoreImagesBtn.classList.remove('d-none'); // Show button again on error
            // Optionally display an error message to the user
          } finally {
            isLoadingImages = false;
            imageLoadingSpinner.classList.add('d-none');
          }
        });
      }
      // --- End Lazy Loading Logic ---

      // --- Event Listener for Image Deletion ---
      const imageGalleryContainer = document.getElementById('image-gallery-grid'); // Or a higher parent if needed

      if (imageGalleryContainer) {
        imageGalleryContainer.addEventListener('submit', async function(event) {
          if (event.target.classList.contains('delete-image-button')) {
            event.preventDefault(); // Prevent default form submission

            const form = event.target;
            const actionUrl = form.action;
            const imageContainer = form.closest('.image-container');
            const imageId = imageContainer ? imageContainer.dataset.imageId : null;

            if (!imageId) {
              console.error('Could not find imageId for deletion.');
              return;
            }

            const deleteButton = form.querySelector('button[type="submit"]');
            const originalButtonContent = deleteButton.innerHTML;
            deleteButton.disabled = true;
            deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

            try {
              const response = await fetch(actionUrl, {
                method: 'POST', // Ensure this matches your route definition (POST)
                headers: {
                  // Add CSRF token header here if your application uses them
                  'Content-Type': 'application/json' // Though body is not sent, server might expect this
                },
                // No body is needed for this specific POST based on controller, but fetch might require it for POST
                // body: JSON.stringify({}) // Send empty JSON object if server expects a body for POST
              });

              if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Failed to delete image. Server error.' }));
                throw new Error(errorData.message || 'Failed to delete image');
              }

              // Success!
              if (imageContainer) {
                imageContainer.remove();
              }

              // Remove from modal carousel
              const carouselItemToRemove = modalImageCarouselInner.querySelector(`.carousel-item[data-image-id="${imageId}"]`);
              if (carouselItemToRemove) {
                const carousel = bootstrap.Carousel.getInstance(imageCarousel);
                const activeCarouselItem = modalImageCarouselInner.querySelector('.carousel-item.active');
                let newActiveIndex = 0;

                if (carousel && activeCarouselItem && activeCarouselItem.dataset.imageId === imageId) {
                  // If the deleted image was active, decide where to go next
                  const items = Array.from(modalImageCarouselInner.children);
                  const currentIndex = items.indexOf(carouselItemToRemove);

                  carouselItemToRemove.remove(); // Remove it first
                  const remainingItems = modalImageCarouselInner.children;

                  if (remainingItems.length > 0) {
                    if (currentIndex >= remainingItems.length) {
                      newActiveIndex = remainingItems.length - 1; // Go to new last item
                    } else {
                      newActiveIndex = currentIndex; // Go to item that took its place
                    }
                    carousel.to(newActiveIndex);
                    // Manually trigger a slide event if it was the active one and modal is open, to reload comments etc.
                    // Or simply close the modal if it was the active one
                    if(myModalEl.classList.contains('show')) {
                        // If only one image was left and it's deleted, close modal
                        if(remainingItems.length === 0) modalInstance.hide();
                        else {
                             // Trigger loadComments for the new active image
                             const newActiveImageElement = remainingItems[newActiveIndex];
                             const newActiveImageId = newActiveImageElement.dataset.imageId;
                             if (newActiveImageId && commentsListElement) {
                                loadComments(newActiveImageId, commentsListElement);
                                history.replaceState(null, '', `#image-${newActiveImageId}`);
                             }
                             if (commentForm && newActiveImageId) {
                                commentForm.dataset.imageId = newActiveImageId;
                             }
                        }
                    }
                  } else {
                     modalInstance.hide(); // No items left, hide modal
                  }
                } else if (carouselItemToRemove) {
                  carouselItemToRemove.remove(); // Just remove if not active
                }
                // Update carousel instance if items were removed to prevent issues
                if (carouselInstance && modalImageCarouselInner.children.length === 0) {
                  // If all images removed, maybe clear modal content or disable carousel buttons.
                } else if (carouselInstance) {
                  // Bootstrap 5 should handle item removal dynamically.
                  // If issues, may need: carouselInstance.dispose(); new bootstrap.Carousel(imageCarousel);
                }
              }

              // Check if any images are left in the gallery
              const remainingImagesInGallery = imageGalleryGrid.querySelectorAll('.image-container').length;
              if (remainingImagesInGallery === 0) {
                if (imageGalleryGrid.parentElement) { // Assuming .detail-item is the parent
                    const detailItem = imageGalleryGrid.closest('.detail-item');
                    const updatesHeader = detailItem.querySelector('.updates-header');

                    imageGalleryGrid.remove(); // Remove the grid
                    // Remove load more button if it exists and no images
                    const loadMoreContainer = detailItem.querySelector('.load-more-container');
                    if(loadMoreContainer) loadMoreContainer.remove();

                    let noImagesMessage = detailItem.querySelector('.no-images-message');
                    if (!noImagesMessage) {
                        noImagesMessage = document.createElement('p');
                        noImagesMessage.classList.add('secondary-text', 'no-images-message');
                        noImagesMessage.textContent = 'No images to see yet.';
                        updatesHeader.insertAdjacentElement('afterend', noImagesMessage);
                    }
                }
              }
                 // Update totalImages and hasMoreImages related variables if needed
                 // This might involve decrementing a global or passed-in totalImages count
                 // and re-evaluating if the "Load More" button should be visible.

            } catch (error) {
              console.error('Error deleting image:', error);
              alert('Error deleting image: ' + error.message); // Simple alert for now
            } finally {
              deleteButton.disabled = false;
              deleteButton.innerHTML = originalButtonContent;
            }
          }
        });
      }
      // --- End Event Listener for Image Deletion ---

      // --- Event Listener for File Deletion ---
      const fileListContainer = document.getElementById('file-list-container');

      if (fileListContainer) {
        fileListContainer.addEventListener('click', async function(event) {
          const deleteButton = event.target.closest('.file-delete-btn');
          if (!deleteButton) return; // Click was not on a delete button

          event.preventDefault(); // Prevent default form submission if it was type="submit"

          const fileId = deleteButton.dataset.fileId;
          const fileItemElement = document.getElementById(`file-item-${fileId}`);

          if (!fileId || !fileItemElement) {
            console.error('Could not find fileId or file item element for deletion.');
            return;
          }

          // Add spinner to button
          const originalButtonContent = deleteButton.innerHTML;
          deleteButton.disabled = true;
          deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

          try {
            const response = await fetch(`/users/${projectUserId}/project/${projectId}/file/${fileId}/delete`, {
              method: 'POST', // Ensure this matches your route definition (POST)
              headers: {
                'Content-Type': 'application/json'
                // Add CSRF token header here if your application uses them
              },
              // body: JSON.stringify({}) // Sending an empty body for POST as publicId is in URL
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: 'Failed to delete file. Server error.' }));
              throw new Error(errorData.message || 'Failed to delete file');
            }

            // Success! Remove the file item from the DOM
            fileItemElement.remove();

            // Check if any files are left
            const remainingFiles = fileListContainer.querySelectorAll('.file-item').length;
            if (remainingFiles === 0) {
              let noFilesMessage = document.getElementById('no-files-message');
              if (noFilesMessage) {
                 noFilesMessage.style.display = 'block'; // Or set text content
              } else {
                // If the "no files" message element might have been removed or doesn't exist, create it
                const filesSection = fileListContainer.closest('.updates-container'); // Find the parent .updates-container
                if(filesSection) {
                    noFilesMessage = document.createElement('p');
                    noFilesMessage.classList.add('secondary-text');
                    noFilesMessage.id = 'no-files-message';
                    noFilesMessage.textContent = 'No files to see yet.';
                    fileListContainer.insertAdjacentElement('afterend', noFilesMessage); // Insert after the (now empty) list
                }
              }
            }

          } catch (error) {
            console.error('Error deleting file:', error);
            alert('Error deleting file: ' + error.message); // Simple alert for user
          } finally {
            // Restore button
            deleteButton.disabled = false;
            deleteButton.innerHTML = originalButtonContent;
          }
        });
      }
      // --- End Event Listener for File Deletion ---

    });